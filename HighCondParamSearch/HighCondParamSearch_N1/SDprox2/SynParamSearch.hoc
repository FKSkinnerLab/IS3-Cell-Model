// This script is used to search the synaptic parameter space of the IS3 model by varying the number of excitatory and inhibitory synapses as well as their presynaptic spike rates

load_file("nrngui.hoc")
load_file("IS3_M2_Case9StarRevised.hoc") // Loads IS3 model with full morphology & properties (as well as parameters and point processes)
		
excsyncount = 0
inhsyncount = 0
count = 0 // for indexing purposes to do with the input vectors
for (dendn = 0; dendn<=57; dendn = dendn+1){
	print "Section Number: ", dendn_vec.x[dendn]
			
	for (i = 1; i<=dend[dendn].nseg; i = i+1) {
		if (dendn > 17 && dendn < 23) { // Skip putting synapses on axonal segments
			count = count + 1
		 	break
		}
	
		// Specifies proportion along section (i.e. from 0 to 1)
		prop = ((dend[dendn].L/dend[dendn].nseg)*i - (dend[dendn].L/dend[dendn].nseg)/2)/dend[dendn].L // finds the center of each segment, as defined by its proportional distance along each section; (prop = (i-0.5)/dend[dendn].nseg also works)
								
		// If in SR
		if (distance(prop)<=300) {
			synlayer = 1 // for indexing the layer in which the synapse is located
		}		
		
		// If in SLM
		if (distance(prop)>300) { // i.e. if greater than 300 um away from soma
			synlayer = 2 // for indexing the layer in which the synapse is located
		}
		
		// Assign optimized synapse parameter values to 9 excitatory synapses on the compartment
		access dend[dendn]
		for (l = 1; l<=9; l = l + 1){
			excsynapses[excsyncount] = new Exp2Syn(prop)
			dend[dendn] excsynapses[excsyncount].loc(prop) // assign to current compartment
			excsynapses[excsyncount].tau1 = risetime_vec.x[count]
			excsynapses[excsyncount].tau2 = decaytime_vec.x[count]
			excsynapses[excsyncount].e = 0
			excnss[excsyncount] = new NetStim(prop)
			excnss[excsyncount].number = 0
			excnss[excsyncount].interval = tstop
			excnss[excsyncount].start = tstop
			excnss[excsyncount].noise = 0
			excncs[excsyncount] = new NetCon(excnss[excsyncount], excsynapses[excsyncount])
			excncs[excsyncount].weight = minweight_vec.x[count]
			synlayer_vec.x[excsyncount] = synlayer
			excsyncount = excsyncount + 1
		}
			
			
		// Assign optimized synapse parameter values to 2 inhibitory synapses on the compartment
		for (m = 1; m<=2; m = m + 1){
			inhsynapses[inhsyncount] = new Exp2Syn(prop)
			dend[dendn] inhsynapses[inhsyncount].loc(prop) // assign to current compartment
			inhsynapses[inhsyncount].tau1 = risetimeinh_vec.x[count]
			inhsynapses[inhsyncount].tau2 = decaytimeinh_vec.x[count]
			inhsynapses[inhsyncount].e = -70
			inhnss[inhsyncount] = new NetStim(prop)
			inhnss[inhsyncount].number = 0
			inhnss[inhsyncount].interval = tstop
			inhnss[inhsyncount].start = tstop
			inhnss[inhsyncount].noise = 0
			inhncs[inhsyncount] = new NetCon(inhnss[inhsyncount], inhsynapses[inhsyncount])
			inhncs[inhsyncount].weight = minweightinh_vec.x[count]
			inhsyncount = inhsyncount + 1
		}
		count = count + 1		
	}	
}

// Generate randomized indexing for random synapse selection
objref r, randexcindex, randinhindex
r = new Random()
randexcindex = new Vector(nexcsyns)
randinhindex = new Vector(ninhsyns)
tempindex = 0
repeats = 1 // Initialize at 1 so it does skip the while loop
for (i = 0; i <= nexcsyns-1; i = i + 1){
	while (repeats > 0){
		repeats = 0 // Reset the count of repeats to 0 for next iteration
		tempindex = r.discunif(0, nexcsyns) // Generate random integer
		for k=0,nexcsyns-1 repeats = repeats + (tempindex == randexcindex.x[k]) // Check if value repeats (i.e. if repeats > 0)
	}
	randexcindex.x[i] = tempindex // Assign value if not repeated
	repeats = 1 // Re-initialize to 1 so it doesn't skip while loop
}
tempindex = 0
repeats = 1 // Initialize at 1 so it does skip the while loop
for (i = 0; i <= ninhsyns-1; i = i + 1){
	while (repeats > 0){
		repeats = 0 // Reset the count of repeats to 0 for next iteration
		tempindex = r.discunif(0, ninhsyns) // Generate random integer
		for k=0,ninhsyns-1 repeats = repeats + (tempindex == randinhindex.x[k]) // Check if value repeats (i.e. if repeats > 0)
	}
	randinhindex.x[i] = tempindex // Assign value if not repeated
	repeats = 1 // Re-initialize to 1 so it doesn't skip while loop
}

// Code for checking values in random index vectors:
// for i=0,nexcsyns-1 print randexcindex.x[i] // Print Vectors
// for i=0,ninhsyns-1 print randinhindex.x[i]
// sum1 = 0
// sum2 = 0
// for i=0,nexcsyns-1 sum1 = sum1 + randexcindex.x[i]
// for i=0,nexcsyns sum2 = sum2 + i // should give same value as sum1
// print "Excitatory Synapse Index Sum: ", sum1, "should equal ", sum2
// sum1 = 0
// sum2 = 0
// for i=0,ninhsyns-1 sum1 = sum1 + randinhindex.x[i]
// for i=0,ninhsyns sum2 = sum2 + i // should give same value as sum1
// print "Inhibitory Synapse Index Sum: ", sum1, "should equal ", sum2


// Run Parameter Search
excsyncount = 0
inhsyncount = 0
excsynspikes = 0
inhsynspikes = 0
maxspikes = 5
spikeresolution = 1
nexcsyns = 80 // Only add up to ~1/20 of total number of excitatory synpases
ninhsyns = 18 // Only add up to ~1/20 of total number of inhibitory synpases
count = 0
access soma
	
for (inhsyncount = 0; inhsyncount < ninhsyns; inhsyncount = inhsyncount + 1){
	
	if (inhsyncount == 0){ // Re-initialize all synapses such that they are silent when restarting a loop
		for i=0,ninhsyns-1 inhnss[randinhindex.x[i]].number = 0
		for i=0,ninhsyns-1 inhnss[randinhindex.x[i]].interval = tstop
		for i=0,ninhsyns-1 inhnss[randinhindex.x[i]].start = 0
		for i=0,ninhsyns-1 inhnss[randinhindex.x[i]].noise = 0
	}
	
	for (excsyncount = 0; excsyncount < nexcsyns; excsyncount = excsyncount + 1){
		
		if (excsyncount == 0){ // Re-initialize all synapses such that they are silent when restarting a loop
			for i=0,nexcsyns-1 excnss[randexcindex.x[i]].number = 0
			for i=0,nexcsyns-1 excnss[randexcindex.x[i]].interval = tstop
			for i=0,nexcsyns-1 excnss[randexcindex.x[i]].start = 0
			for i=0,nexcsyns-1 excnss[randexcindex.x[i]].noise = 0
		}
		
		for (inhsynspikes = 1; inhsynspikes <= maxspikes; inhsynspikes = inhsynspikes + spikeresolution){
			for (excsynspikes = 1; excsynspikes <= maxspikes; excsynspikes = excsynspikes + spikeresolution){
				
				for i=0,excsyncount excnss[randexcindex.x[i]].number = excsynspikes
				for i=0,excsyncount excnss[randexcindex.x[i]].interval = tstop/excsynspikes
				for i=0,excsyncount excnss[randexcindex.x[i]].start = 0
				for i=0,excsyncount excnss[randexcindex.x[i]].noise = 1
					
				for i=0,inhsyncount inhnss[randinhindex.x[i]].number = inhsynspikes
				for i=0,inhsyncount inhnss[randinhindex.x[i]].interval = tstop/inhsynspikes
				for i=0,inhsyncount inhnss[randinhindex.x[i]].start = 0
				for i=0,inhsyncount inhnss[randinhindex.x[i]].noise = 1
				
				// Run Simulation and Record Vm Vector
				recV = new Vector()
				recV.record(&soma.v(0.5))
				run()
				sprint(filename1,"model_%g_NumInh_%g_NumExc_%g_InhSpikes_%g_ExcSpikes.dat",inhsyncount+1,excsyncount+1,inhsynspikes,excsynspikes) // Changes filename on each iteration
				frecV = new File(filename1)
				frecV.wopen(filename1)
				recV.vwrite(frecV) // Use printf instead of vwrite if you want a text file instead of a binary file
				frecV.close()	
					
				count = count + 1
				print "Model Number = ", count, " of", nexcsyns*ninhsyns*(((maxspikes-1)/spikeresolution)^2)
			}
		}
	}
}
