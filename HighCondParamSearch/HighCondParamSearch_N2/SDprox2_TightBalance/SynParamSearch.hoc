// This script is used to search the synaptic parameter space of the IS3 model by varying the number of excitatory and inhibitory synapses as well as their presynaptic spike rates

load_file("nrngui.hoc")
load_file("IS3_M2_Case9StarRevised.hoc") // Loads IS3 model with full morphology & properties (as well as parameters and point processes)
		
excsyncount = 0
inhsyncount = 0
count = 0 // for indexing purposes to do with the input vectors
for (dendn = 0; dendn<=57; dendn = dendn+1){
	print "Section Number: ", dendn_vec.x[dendn]
			
	for (i = 1; i<=dend[dendn].nseg; i = i+1) {
		if (dendn > 17 && dendn < 23) { // Skip putting synapses on axonal segments
			count = count + 1
		 	break
		}
	
		// Specifies proportion along section (i.e. from 0 to 1)
		prop = ((dend[dendn].L/dend[dendn].nseg)*i - (dend[dendn].L/dend[dendn].nseg)/2)/dend[dendn].L // finds the center of each segment, as defined by its proportional distance along each section; (prop = (i-0.5)/dend[dendn].nseg also works)
								
		// If in SR
		if (distance(prop)<=300) {
			synlayer = 1 // for indexing the layer in which the synapse is located
		}		
		
		// If in SLM
		if (distance(prop)>300) { // i.e. if greater than 300 um away from soma
			synlayer = 2 // for indexing the layer in which the synapse is located
		}
		
		// Assign optimized synapse parameter values to 9 excitatory synapses on the compartment
		access dend[dendn]
		for (l = 1; l<=9; l = l + 1){
			excsynapses[excsyncount] = new Exp2Syn(prop)
			dend[dendn] excsynapses[excsyncount].loc(prop) // assign to current compartment
			excsynapses[excsyncount].tau1 = risetime_vec.x[count]
			excsynapses[excsyncount].tau2 = decaytime_vec.x[count]
			excsynapses[excsyncount].e = 0
			excnss[excsyncount] = new VecStim(prop)
			excncs[excsyncount] = new NetCon(excnss[excsyncount], excsynapses[excsyncount])
			excncs[excsyncount].weight = minweight_vec.x[count]
			synlayer_vec.x[excsyncount] = synlayer
			excsyncount = excsyncount + 1
		}
			
			
		// Assign optimized synapse parameter values to 2 inhibitory synapses on the compartment
		for (m = 1; m<=2; m = m + 1){
			inhsynapses[inhsyncount] = new Exp2Syn(prop)
			dend[dendn] inhsynapses[inhsyncount].loc(prop) // assign to current compartment
			inhsynapses[inhsyncount].tau1 = risetimeinh_vec.x[count]
			inhsynapses[inhsyncount].tau2 = decaytimeinh_vec.x[count]
			inhsynapses[inhsyncount].e = -70
			inhnss[inhsyncount] = new VecStim(prop)
			inhncs[inhsyncount] = new NetCon(inhnss[inhsyncount], inhsynapses[inhsyncount])
			inhncs[inhsyncount].weight = minweightinh_vec.x[count]
			inhsyncount = inhsyncount + 1
		}
		count = count + 1		
	}	
}

// Generate randomized indexing for random synapse selection
objref r, randexcindex, randinhindex
r = new Random()
randexcindex = new Vector(nexcsyns)
randinhindex = new Vector(ninhsyns)
tempindex = 0
repeats = 1 // Initialize at 1 so it does skip the while loop
for (i = 0; i <= nexcsyns-1; i = i + 1){
	while (repeats > 0){
		repeats = 0 // Reset the count of repeats to 0 for next iteration
		tempindex = r.discunif(0, nexcsyns) // Generate random integer
		for k=0,nexcsyns-1 repeats = repeats + (tempindex == randexcindex.x[k]) // Check if value repeats (i.e. if repeats > 0)
	}
	randexcindex.x[i] = tempindex // Assign value if not repeated
	repeats = 1 // Re-initialize to 1 so it doesn't skip while loop
}
tempindex = 0
repeats = 1 // Initialize at 1 so it does skip the while loop
for (i = 0; i <= ninhsyns-1; i = i + 1){
	while (repeats > 0){
		repeats = 0 // Reset the count of repeats to 0 for next iteration
		tempindex = r.discunif(0, ninhsyns) // Generate random integer
		for k=0,ninhsyns-1 repeats = repeats + (tempindex == randinhindex.x[k]) // Check if value repeats (i.e. if repeats > 0)
	}
	randinhindex.x[i] = tempindex // Assign value if not repeated
	repeats = 1 // Re-initialize to 1 so it doesn't skip while loop
}

objectvar frandexcindex
sprint(filename2,"model_RandomizedExcitatoryIndices.dat")
frandexcindex = new File(filename2)
frandexcindex.wopen(filename2)
randexcindex.printf(frandexcindex) // Use printf instead of vwrite if you want a text file instead of a binary file
frandexcindex.close()

objectvar frandinhindex
sprint(filename3,"model_RandomizedInhibitoryIndices.dat")
frandinhindex = new File(filename3)
frandinhindex.wopen(filename3)
randinhindex.printf(frandinhindex) // Use printf instead of vwrite if you want a text file instead of a binary file
frandinhindex.close()

// Code for checking values in random index vectors:
// for i=0,nexcsyns-1 print randexcindex.x[i] // Print Vectors
// for i=0,ninhsyns-1 print randinhindex.x[i]
// sum1 = 0
// sum2 = 0
// for i=0,nexcsyns-1 sum1 = sum1 + randexcindex.x[i]
// for i=0,nexcsyns sum2 = sum2 + i // should give same value as sum1
// print "Excitatory Synapse Index Sum: ", sum1, "should equal ", sum2
// sum1 = 0
// sum2 = 0
// for i=0,ninhsyns-1 sum1 = sum1 + randinhindex.x[i]
// for i=0,ninhsyns sum2 = sum2 + i // should give same value as sum1
// print "Inhibitory Synapse Index Sum: ", sum1, "should equal ", sum2

// Run Parameter Search
excsyncount = 0
inhsyncount = 0
excsynspikes = 0
inhsynspikes = 0
maxspikes = 10*(tstop/1000) // Max 10 Hz so 10 spikes in 1s
nspikesteps = 5 // Number of spike step increases
spikeresolution = maxspikes/nspikesteps
initialspikes = maxspikes/nspikesteps
fractofexcsyns = 20
fractofinhsyns = 20
synres = 3 // Resolution of synapses during parameter search
testnexcsyns = nexcsyns/fractofexcsyns // Only add up to ~1/20 of total number of excitatory synpases
testninhsyns = ninhsyns/fractofinhsyns // Only add up to ~1/20 of total number of inhibitory synpases
count = 0
delay = 5 // Tight E-I coupling delay of 2ms
access soma

// Record presynaptic events at all synapses. 
// Note that rexcvec & rinhvec values should be the same as excprespiketrains & inhprespiketrains values.
objectvar excprespiketrains[nexcsyns], inhprespiketrains[ninhsyns]
for i=0,nexcsyns-1 excprespiketrains[i] = new Vector()
for i=0,ninhsyns-1 inhprespiketrains[i] = new Vector()
for i=0,nexcsyns-1 excncs[i].record(excprespiketrains[i])
for i=0,ninhsyns-1 inhncs[i].record(inhprespiketrains[i])

// Create random uniform sample for spikes times
objectvar rexc, rexcvec, rinh, rinhvec, frecExcPreSpikeTrains, frecInhPreSpikeTrains, rexcMat, rinhMat
rexc = new Random(1)
rexc.uniform(0,tstop-delay) // Subtract delay such that no inhibitory spikes go beyond the simulation time
rinh = new Random(2)
rinh.uniform(0,tstop-delay) 

for (inhsyncount = 0; inhsyncount < testninhsyns; inhsyncount = inhsyncount + synres){
	
	if (inhsyncount == 0){ // Re-initialize all synapses such that they are silent when restarting a loop
		rinhvec = new Vector(0)
		for i=0,testninhsyns-1 inhnss[randinhindex.x[i]].play(rinhvec)
	}
	
	for (excsyncount = 0; excsyncount < testnexcsyns; excsyncount = excsyncount + synres){
		
		if (excsyncount == 0){ // Re-initialize all synapses such that they are silent when restarting a loop
			rexcvec = new Vector(0)
			for i=0,testnexcsyns-1 excnss[randexcindex.x[i]].play(rexcvec)
		}
		
		for (inhsynspikes = initialspikes; inhsynspikes <= maxspikes; inhsynspikes = inhsynspikes + spikeresolution){
			for (excsynspikes = initialspikes; excsynspikes <= maxspikes; excsynspikes = excsynspikes + spikeresolution){

				///// Section for Randomly Picking Excitatory Spike Times /////
				rexcMat = new Matrix(excsyncount+1,excsynspikes)
				for (i=0; i < excsyncount+1; i = i + 1){ 
					rexcvec = new Vector(excsynspikes)
					rexcvec.setrand(rexc) 
					rexcvec.sort()
					excnss[randexcindex.x[i]].play(rexcvec)
					
					// Build Spike Time Matrix
					for k=0,excsynspikes-1 rexcMat.x[i][k] = rexcvec.x[k]
				}

				rinhMat = new Matrix(inhsyncount+1,inhsynspikes)

				///////////////////////////////////////////////////////////////////////////////////////////////////
				///// Section for Correlating Inhibitory Spikes Times to Excitatory Spike Times When Possible /////
				///////////////////////////////////////////////////////////////////////////////////////////////////
				if (inhsyncount <= excsyncount && inhsynspikes <= excsynspikes){
					for (i=0; i < inhsyncount+1; i = i + 1){ 
						rinhvec = new Vector(inhsynspikes)
						for l=0,inhsynspikes-1 rinhvec.x[l] = rexcMat.x[i][l*(excsynspikes/inhsynspikes)] + delay // So that inhibitory spikes occur shortly after excitatory spikes
						inhnss[randinhindex.x[i]].play(rinhvec)

						// Build Spike Time Matrix
						for k=0,inhsynspikes-1 rinhMat.x[i][k] = rinhvec.x[k]
					}
				}
				if (inhsyncount <= excsyncount && inhsynspikes > excsynspikes){
					for (i=0; i < inhsyncount+1; i = i + 1){ 
						rinhvec = new Vector(inhsynspikes)
						for l=0,excsynspikes-1 rinhvec.x[l] = rexcMat.x[i][l] + delay // If still less inh spikes than exc spikes, sample from exc spike matrix
						for l=excsynspikes,inhsynspikes-1 rinhvec.x[l] = rinh.repick() // When more inh spikes than exc spikes, sample from random spike times instead
						rinhvec.sort()
						inhnss[randinhindex.x[i]].play(rinhvec)

						// Build Spike Time Matrix
						for k=0,inhsynspikes-1 rinhMat.x[i][k] = rinhvec.x[k]
					}
				}
				if (inhsyncount > excsyncount && inhsynspikes <= excsynspikes){
					for (i=0; i < excsyncount+1; i = i + 1){ 
						rinhvec = new Vector(inhsynspikes)
						for l=0,inhsynspikes-1 rinhvec.x[l] = rexcMat.x[i][l*(excsynspikes/inhsynspikes)] + delay // If still less inh synapses than exc synapses, sample from exc spikes matrix
						inhnss[randinhindex.x[i]].play(rinhvec)

						// Build Spike Time Matrix
						for k=0,inhsynspikes-1 rinhMat.x[i][k] = rinhvec.x[k]
					}
					for (i=excsyncount+1; i < inhsyncount+1; i = i + 1){ 
						rinhvec = new Vector(inhsynspikes)
						for l=0,inhsynspikes-1 rinhvec.x[l] = rinh.repick() // When more inh synapses than exc synapses, sample from random spike times instead
						rinhvec.sort()
						inhnss[randinhindex.x[i]].play(rinhvec)

						// Build Spike Time Matrix
						for k=0,inhsynspikes-1 rinhMat.x[i][k] = rinhvec.x[k]
					}
				}
				if (inhsyncount > excsyncount && inhsynspikes > excsynspikes){
					for (i=0; i < excsyncount+1; i = i + 1){ 
						rinhvec = new Vector(inhsynspikes)
						for l=0,excsynspikes-1 rinhvec.x[l] = rexcMat.x[i][l] + delay // If still less inh synapses than exc synapses, sample from exc spikes matrix
						for l=excsynspikes,inhsynspikes-1 rinhvec.x[l] = rinh.repick() // When more inh spikes than exc spikes, sample from random spike times instead
						rinhvec.sort()
						inhnss[randinhindex.x[i]].play(rinhvec)

						// Build Spike Time Matrix
						for k=0,inhsynspikes-1 rinhMat.x[i][k] = rinhvec.x[k]
					}
					for (i=excsyncount+1; i < inhsyncount+1; i = i + 1){ 
						rinhvec = new Vector(inhsynspikes)
						for l=0,inhsynspikes-1 rinhvec.x[l] = rinh.repick() // When inh synapses than exc synapses, sample from random spike times instead
						rinhvec.sort()
						inhnss[randinhindex.x[i]].play(rinhvec)

						// Build Spike Time Matrix
						for k=0,inhsynspikes-1 rinhMat.x[i][k] = rinhvec.x[k]
					}
				}
				////////////////////////////////////////////////////////////////////////////////////////////////////////////////

				// Save Excitatory Raster Matrix
				sprint(filename4,"ExcPreSpikeTrains_%g_NumInh_%g_NumExc_%g_InhSpikes_%g_ExcSpikes.dat",inhsyncount+1,excsyncount+1,inhsynspikes,excsynspikes)
				frecExcPreSpikeTrains = new File(filename4)
				frecExcPreSpikeTrains.wopen(filename4)
				rexcMat.fprint(frecExcPreSpikeTrains) // Spike times sampled from random distribution
				frecExcPreSpikeTrains.close()

				// Save Inhibitory Raster Matrix
				sprint(filename5,"InhPreSpikeTrains_%g_NumInh_%g_NumExc_%g_InhSpikes_%g_ExcSpikes.dat",inhsyncount+1,excsyncount+1,inhsynspikes,excsynspikes)
				frecInhPreSpikeTrains = new File(filename5)
				frecInhPreSpikeTrains.wopen(filename5)
				rinhMat.fprint(frecInhPreSpikeTrains) // Spike times sampled from random distribution
				frecInhPreSpikeTrains.close()

				// Run Simulation and Record Vm Vector
				recV = new Vector()
				recV.record(&soma.v(0.5))
				run()
				sprint(filename1,"model_%g_NumInh_%g_NumExc_%g_InhSpikes_%g_ExcSpikes.dat",inhsyncount+1,excsyncount+1,inhsynspikes,excsynspikes) // Changes filename on each iteration
				frecV = new File(filename1)
				frecV.wopen(filename1)
				recV.vwrite(frecV) // Use printf instead of vwrite if you want a text file instead of a binary file
				frecV.close()

				count = count + 1
				print "Model Number = ", count, " of ", int(testnexcsyns/synres)*int(testninhsyns/synres)*(nspikesteps^2)
			}
		}
	}
}
