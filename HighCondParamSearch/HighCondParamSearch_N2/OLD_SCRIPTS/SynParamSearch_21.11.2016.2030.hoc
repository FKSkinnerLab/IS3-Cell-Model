// This script is used to search the synaptic parameter space of the IS3 model by varying the number of excitatory and inhibitory synapses as well as their presynaptic spike rates

load_file("nrngui.hoc")
load_file("IS3_M2_Case8StarRevised.hoc") // Loads IS3 model with full morphology & properties (as well as parameters and point processes)
		
excsyncount = 0
inhsyncount = 0
count = 0 // for indexing purposes to do with the input vectors
for (dendn = 0; dendn<=57; dendn = dendn+1){
	print "Section Number: ", dendn_vec.x[dendn]
			
	for (i = 1; i<=dend[dendn].nseg; i = i+1) {
		if (dendn > 17 && dendn < 23) { // Skip putting synapses on axonal segments
			count = count + 1
		 	break
		}
	
		// Specifies proportion along section (i.e. from 0 to 1)
		prop = ((dend[dendn].L/dend[dendn].nseg)*i - (dend[dendn].L/dend[dendn].nseg)/2)/dend[dendn].L // finds the center of each segment, as defined by its proportional distance along each section; (prop = (i-0.5)/dend[dendn].nseg also works)
								
		// If in SR
		if (distance(prop)<=300) {
			synlayer = 1 // for indexing the layer in which the synapse is located
		}		
		
		// If in SLM
		if (distance(prop)>300) { // i.e. if greater than 300 um away from soma
			synlayer = 2 // for indexing the layer in which the synapse is located
		}
		
		// Assign optimized synapse parameter values to 9 excitatory synapses on the compartment
		access dend[dendn]
		for (l = 1; l<=9; l = l + 1){
			excsynapses[excsyncount] = new Exp2Syn(prop)
			dend[dendn] excsynapses[excsyncount].loc(prop) // assign to current compartment
			excsynapses[excsyncount].tau1 = risetime_vec.x[count]
			excsynapses[excsyncount].tau2 = decaytime_vec.x[count]
			excsynapses[excsyncount].e = 0
			excnss[excsyncount] = new VecStim(prop)
			excncs[excsyncount] = new NetCon(excnss[excsyncount], excsynapses[excsyncount])
			excncs[excsyncount].weight = minweight_vec.x[count]
			synlayer_vec.x[excsyncount] = synlayer
			excsyncount = excsyncount + 1
		}
			
			
		// Assign optimized synapse parameter values to 2 inhibitory synapses on the compartment
		for (m = 1; m<=2; m = m + 1){
			inhsynapses[inhsyncount] = new Exp2Syn(prop)
			dend[dendn] inhsynapses[inhsyncount].loc(prop) // assign to current compartment
			inhsynapses[inhsyncount].tau1 = risetimeinh_vec.x[count]
			inhsynapses[inhsyncount].tau2 = decaytimeinh_vec.x[count]
			inhsynapses[inhsyncount].e = -70
			inhnss[inhsyncount] = new VecStim(prop)
			inhncs[inhsyncount] = new NetCon(inhnss[inhsyncount], inhsynapses[inhsyncount])
			inhncs[inhsyncount].weight = minweightinh_vec.x[count]
			inhsyncount = inhsyncount + 1
		}
		count = count + 1		
	}	
}

// Generate randomized indexing for random synapse selection
objref r, randexcindex, randinhindex
r = new Random()
randexcindex = new Vector(nexcsyns)
randinhindex = new Vector(ninhsyns)
tempindex = 0
repeats = 1 // Initialize at 1 so it does skip the while loop
for (i = 0; i <= nexcsyns-1; i = i + 1){
	while (repeats > 0){
		repeats = 0 // Reset the count of repeats to 0 for next iteration
		tempindex = r.discunif(0, nexcsyns) // Generate random integer
		for k=0,nexcsyns-1 repeats = repeats + (tempindex == randexcindex.x[k]) // Check if value repeats (i.e. if repeats > 0)
	}
	randexcindex.x[i] = tempindex // Assign value if not repeated
	repeats = 1 // Re-initialize to 1 so it doesn't skip while loop
}
tempindex = 0
repeats = 1 // Initialize at 1 so it does skip the while loop
for (i = 0; i <= ninhsyns-1; i = i + 1){
	while (repeats > 0){
		repeats = 0 // Reset the count of repeats to 0 for next iteration
		tempindex = r.discunif(0, ninhsyns) // Generate random integer
		for k=0,ninhsyns-1 repeats = repeats + (tempindex == randinhindex.x[k]) // Check if value repeats (i.e. if repeats > 0)
	}
	randinhindex.x[i] = tempindex // Assign value if not repeated
	repeats = 1 // Re-initialize to 1 so it doesn't skip while loop
}

objectvar frandexcindex
sprint(filename2,"model_RandomizedExcitatoryIndices.dat")
frandexcindex = new File(filename2)
frandexcindex.wopen(filename2)
randexcindex.printf(frandexcindex) // Use printf instead of vwrite if you want a text file instead of a binary file
frandexcindex.close()

objectvar frandinhindex
sprint(filename3,"model_RandomizedInhibitoryIndices.dat")
frandinhindex = new File(filename3)
frandinhindex.wopen(filename3)
randinhindex.printf(frandinhindex) // Use printf instead of vwrite if you want a text file instead of a binary file
frandinhindex.close()

// Code for checking values in random index vectors:
// for i=0,nexcsyns-1 print randexcindex.x[i] // Print Vectors
// for i=0,ninhsyns-1 print randinhindex.x[i]
// sum1 = 0
// sum2 = 0
// for i=0,nexcsyns-1 sum1 = sum1 + randexcindex.x[i]
// for i=0,nexcsyns sum2 = sum2 + i // should give same value as sum1
// print "Excitatory Synapse Index Sum: ", sum1, "should equal ", sum2
// sum1 = 0
// sum2 = 0
// for i=0,ninhsyns-1 sum1 = sum1 + randinhindex.x[i]
// for i=0,ninhsyns sum2 = sum2 + i // should give same value as sum1
// print "Inhibitory Synapse Index Sum: ", sum1, "should equal ", sum2


// Run Parameter Search
excsyncount = 0
inhsyncount = 0
excsynspikes = 0
inhsynspikes = 0
maxspikes = 10*(tstop/1000) // Max 10 Hz so 10 spikes in 1s
nspikesteps = 5 // Number of spike step increases
spikeresolution = maxspikes/nspikesteps
initialspikes = maxspikes/nspikesteps
fractofexcsyns = 20
fractofinhsyns = 20
testnexcsyns = nexcsyns/fractofexcsyns // Only add up to ~1/20 of total number of excitatory synpases
testninhsyns = ninhsyns/fractofinhsyns // Only add up to ~1/8 of total number of inhibitory synpases
count = 0
access soma

// Record presynaptic events at all synapses. 
// Note that rexcvec & rinhvec values should be the same as excprespiketrains & inhprespiketrains values.
objectvar excprespiketrains[nexcsyns], inhprespiketrains[ninhsyns]
for i=0,nexcsyns-1 excprespiketrains[i] = new Vector()
for i=0,ninhsyns-1 inhprespiketrains[i] = new Vector()
for i=0,nexcsyns-1 excncs[i].record(excprespiketrains[i])
for i=0,ninhsyns-1 inhncs[i].record(inhprespiketrains[i])

// Create random uniform sample for spikes times
objectvar rexc, rexcvec, rinh, rinhvec, frecExcPreSpikeTrains, frecInhPreSpikeTrains
rexc = new Random()
rexc.uniform(0,tstop)
rinh = new Random()
rinh.uniform(0,tstop)

for (inhsyncount = 0; inhsyncount < testninhsyns; inhsyncount = inhsyncount + 1){
	
	if (inhsyncount == 0){ // Re-initialize all synapses such that they are silent when restarting a loop
		rinhvec = new Vector(0)
		for i=0,testninhsyns-1 inhnss[randinhindex.x[i]].play(rinhvec)
	}
	
	for (excsyncount = 0; excsyncount < testnexcsyns; excsyncount = excsyncount + 1){
		
		if (excsyncount == 0){ // Re-initialize all synapses such that they are silent when restarting a loop
			rexcvec = new Vector(0)
			for i=0,testnexcsyns-1 excnss[randexcindex.x[i]].play(rexcvec)
		}
		
		for (inhsynspikes = initialspikes; inhsynspikes <= maxspikes; inhsynspikes = inhsynspikes + spikeresolution){
			for (excsynspikes = initialspikes; excsynspikes <= maxspikes; excsynspikes = excsynspikes + spikeresolution){
				
				// Open exc presynaptic spike times file
				sprint(filename4,"ExcPreSpikeTrains_%g_NumInh_%g_NumExc_%g_InhSpikes_%g_ExcSpikes.dat",inhsyncount+1,excsyncount+1,inhsynspikes,excsynspikes)
				frecExcPreSpikeTrains = new File(filename4)
				frecExcPreSpikeTrains.wopen(filename4)
				
				// Assign exc presynaptic spike times and record to file
				for (i=0; i < excsyncount+1; i = i + 1){ 
					rexcvec = new Vector(excsynspikes)
					rexcvec.setrand(rexc) 
					rexcvec.sort()
					excnss[randexcindex.x[i]].play(rexcvec)

					rexcvec.printf(frecExcPreSpikeTrains) // Spike times sampled from random distribution
				}
				// Close exc presynaptic spike times file
				frecExcPreSpikeTrains.close()

				// Open inh presynaptic spike times file
				sprint(filename5,"InhPreSpikeTrains_%g_NumInh_%g_NumExc_%g_InhSpikes_%g_ExcSpikes.dat",inhsyncount+1,excsyncount+1,inhsynspikes,excsynspikes)
				frecInhPreSpikeTrains = new File(filename5)
				frecInhPreSpikeTrains.wopen(filename5)

				// Assign inh presynaptic spike times and record to file
				for (i=0; i < inhsyncount+1; i = i + 1){ 
					rinhvec = new Vector(inhsynspikes)
					rinhvec.setrand(rinh) 
					rinhvec.sort()
					inhnss[randinhindex.x[i]].play(rinhvec)

					rinhvec.printf(frecInhPreSpikeTrains) // Spike times sampled from random distribution
				}
				// Close inh presynaptic spike times file
				frecInhPreSpikeTrains.close()

				// Run Simulation and Record Vm Vector
				recV = new Vector()
				recV.record(&soma.v(0.5))
				run()
				sprint(filename1,"model_%g_NumInh_%g_NumExc_%g_InhSpikes_%g_ExcSpikes.dat",inhsyncount+1,excsyncount+1,inhsynspikes,excsynspikes) // Changes filename on each iteration
				frecV = new File(filename1)
				frecV.wopen(filename1)
				recV.vwrite(frecV) // Use printf instead of vwrite if you want a text file instead of a binary file
				frecV.close()

				count = count + 1
				print "Model Number = ", count, " of ", int(testnexcsyns)*int(testninhsyns)*(nspikesteps^2)
			}
		}
	}
}
