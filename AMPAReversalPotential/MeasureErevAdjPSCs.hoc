// This script is used to identify synaptic weights necessary to evoke somatic action potentials at different distance from the soma

// Extra info into programmatically incorporating Multiple Run Fitter: https://www.neuron.yale.edu/phpBB/viewtopic.php?f=23&t=805 & http://www.neuron.yale.edu/neuron/static/docs/optimiz/model/set_up_runfitness.html
load_file("nrngui.hoc")
load_file("IS3_M2_Case9StarRevised.hoc") // Loads IS3 model with full morphology & properties (as well as parameters and point processes)
		
syncount = 0
count = 0

// First render the model passive
gna_Nasoma = 0
gksoma_Ksoma = 0
gbar_Ika = 0
gbar_nap = 0
forsec Dendrites {
	gna_Nasoma = 0
	gksoma_Ksoma = 0
}

for (dendn = 0; dendn<=57; dendn = dendn+1){
	print "Section Number: ", dendn
			
	for (i = 1; i<=dend[dendn].nseg; i = i+1) {
		if (dendn > 17 && dendn < 23) { // Skip putting synapses on axonal segments
		 	dist_vec.x[count] = 0
			risetime_vec.x[count] = 0
			decaytime_vec.x[count] = 0
			minweight_vec.x[count] = 0
			risetimeinh_vec.x[count] = 0
			decaytimeinh_vec.x[count] = 0
			minweightinh_vec.x[count] = 0
			dendn_vec.x[count] = 0
			count = count + 1
		 	break
		}
		dendn_vec.x[count] = dendn // Record dendrite number
	
		// Specifies proportion along section (i.e. from 0 to 1)
		prop = ((dend[dendn].L/dend[dendn].nseg)*i - (dend[dendn].L/dend[dendn].nseg)/2)/dend[dendn].L // finds the center of each segment, as defined by its proportional distance along each section; (prop = (i-0.5)/dend[dendn].nseg also works)
		
		// Changes Exp2Syn's location to current proportion along section
		dend[dendn] syn.loc(prop)
		
		// Records distance along section according to current proportion along section
		access dend[dendn]
		dist_vec.x[count] = distance(prop)
								
		// Optimize excitatory synaptic time constants and weights if in SR layer
		if (distance(prop)<=300) {
			synlayer = 1 // for indexing the layer in which the synapse is located
			access soma
			
			// Set voltage clamp	
			vclamp1.dur[0] = tstop
			vclamp1.amp[0] = -70 // Clamp membrane voltage to resting potential (Same as EXP)
			vclamp1.tau1 = 0
			vclamp1.tau2 = 0
			
			noise.stdev = 0 // To faciliate fit to average EPSC (low noise)
			nc.weight = 0.00000230814*dist_vec.x[count] + 0.00022016666 // Initial Weight (Adjustable)
			syn.tau1 = 2.9936e-04 // Initial Rise time (Adjustable)
			syn.tau2 = 2.4216 // Initial Decay time (Adjustable)
			syn.e = 0 // Reversal Potential (mV) (Fixed)
				
			// Record membrane current vector
			recSI = new Vector()
			recSI.record(&vclamp1.i)
			
			for (erev = -70; erev <= 100; erev = erev + 1){
				v_init = erev
				vclamp1.amp[0] = erev
				run()
				if (recSI.x[1090] > recSI.x[1900]){
					erev_vec.x[count] = erev
					break
				}
			}
				
			risetime_vec.x[count] = syn.tau1 // Rise Time (ms)
			decaytime_vec.x[count] = syn.tau2 // Decay Time (ms)
			minweight_vec.x[count] = nc.weight // Optimized Weight (uS)
		}		
		
		// Optimize excitatory synaptic time constants and weights if in SLM layer
		if (distance(prop)>300) { // i.e. if greater than 300 um away from soma
			synlayer = 2 // for indexing the layer in which the synapse is located
			access soma
				
			// To remove passive reversal potential drive
			v_init = -70
	
			// Set voltage clamp
			vclamp1.dur[0] = tstop
			vclamp1.amp[0] = -70 // Clamp membrane voltage to resting potential (Same as EXP)
			vclamp1.tau1 = 0
			vclamp1.tau2 = 0

			noise.stdev = 0 // To faciliate fit to average EPSC (low noise)
			nc.weight = 0.00000230814*dist_vec.x[count] + 0.00022016666 // Initial Weight (Adjustable)
			syn.tau1 = 6.1871e-04 // Initial Rise time (Adjustable)
			syn.tau2 = 3.1975 // Initial Decay time (Adjustable)
			syn.e = 0 // Reversal Potential (mV) (Fixed)
					
			// Record membrane current vector
			recSI = new Vector()
			recSI.record(&vclamp1.i)
			
			for (erev = -70; erev <= 100; erev = erev + 1){
				v_init = erev
				vclamp1.amp[0] = erev
				run()
				if (recSI.x[1090] > recSI.x[1900]){
					erev_vec.x[count] = erev
					break
				}
			}
				
			risetime_vec.x[count] = syn.tau1 // Rise Time (ms)
			decaytime_vec.x[count] = syn.tau2 // Decay Time (ms)
			minweight_vec.x[count] = nc.weight // Optimized Weight (uS)
		}
		count = count + 1
	}	
}
		
// Store all vectors in files
sprint(filename2, "model_distvec.dat")
sprint(model_abs_path2, "%s/%s", MODEL_TOPDIR, filename2)
fdist = new File(filename2)
fdist.wopen(model_abs_path2)
dist_vec.printf(fdist) // Use printf instead of vwrite if you want a text file instead of a binary file
fdist.close()
	
sprint(filename3, "model_erevvec.dat")
sprint(model_abs_path3, "%s/%s", MODEL_TOPDIR, filename3)
ferev = new File(filename3)
ferev.wopen(model_abs_path3)
erev_vec.printf(ferev) // Use printf instead of vwrite if you want a text file instead of a binary file
ferev.close()

sprint(filename5, "model_risetimevec.dat")
sprint(model_abs_path5, "%s/%s", MODEL_TOPDIR, filename5)
frise = new File(filename5)
frise.wopen(model_abs_path5)
risetime_vec.printf(frise)
frise.close()

sprint(filename6, "model_decaytimevec.dat")
sprint(model_abs_path6, "%s/%s", MODEL_TOPDIR, filename6)
fdecay = new File(filename6)
fdecay.wopen(model_abs_path6)
decaytime_vec.printf(fdecay)
fdecay.close()

sprint(filename8, "model_minweightvec.dat")
sprint(model_abs_path8, "%s/%s", MODEL_TOPDIR, filename8)
fminweight = new File(filename8)
fminweight.wopen(model_abs_path8)
minweight_vec.printf(fminweight)
fminweight.close()
	
sprint(filename15, "model_dendsectionvec.dat")
sprint(model_abs_path15, "%s/%s", MODEL_TOPDIR, filename15)
fdendn = new File(filename15)
fdendn.wopen(model_abs_path15)
dendn_vec.printf(fdendn)
fdendn.close()
	