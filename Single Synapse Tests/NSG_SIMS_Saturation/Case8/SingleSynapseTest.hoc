// This script is used to identify synaptic weights necessary to evoke somatic action potentials at different distance from the soma
load_file("nrngui.hoc")
load_file("IS3_M2_Case8TopModel.hoc") // Loads IS3 model with full morphology & properties

access soma
distance()
// Set Parameters
tstop = 100 // (ms)
v_init = -69.7
steps_per_ms = 10
dt = 0.1
dendn = 0 // Specifies section - still need to adjust distance vector though
sec_divs = 221 // Total number of compartments
count = 0
	
// Initialize variables
objectvar noise, AP_N, syn, nc, ns, weight_vec, dist_vec, fok, fdist, nil, fih, frecV, recV
strdef filename, filename2, filename10, MODEL_TOPDIR, model_abs_path, model_abs_path2
	
//MODEL_TOPDIR = "/Users/sandygm5/Desktop/SkinnerLab/Usages/Single\ Synapse\ Tests/SD50TopModelTests/Case9StarTopModelOutput"
	
// Initialize vectors
weight_vec = new Vector(sec_divs+1,0)
dist_vec = new Vector(sec_divs+1,0)
	
// Create Point Processes
soma noise = new InGauss(0) // Simulates stochastic gating
noise.del = 0
noise.dur = tstop
noise.mean = 0
noise.stdev = 0.01 

soma AP_N = new APCount(0) // Counts spikes at soma
AP_N.thresh = -20 // Threshold for rising spike identification

dend[dendn] syn = new Exp2Syn(0) // Creates 1 two state kinetic scheme synapse
syn.tau1 = 0.2 // Rise time
syn.tau2 = 2 // Decay time
syn.e = 0 // Reversal Potential
	
nc = new NetCon(nil, syn) // Specifies a network connection to syn
fih = new FInitializeHandler("nc.event(0)") // Creates 1 presynaptic event during initialization targeted to syn
	
for (dendn = 0; dendn<=57; dendn = dendn+1){
	print dendn
		
	weight_vec = new Vector(dend[dendn].nseg,0)
	dist_vec = new Vector(dend[dendn].nseg,0)
		
	for (i = 1; i<=dend[dendn].nseg; i = i+1) {
	
		// Specifies proportion along section (i.e. from 0 to 1)
		prop = ((dend[dendn].L/dend[dendn].nseg)*i - (dend[dendn].L/dend[dendn].nseg)/2)/dend[dendn].L // finds the center of each segment, as defined by its proportional distance along each section; (prop = (i-0.5)/dend[dendn].nseg also works)
		
		// Changes Exp2Syn's location to current proportion along section
		dend[dendn] syn.loc(prop)
			
		// Records distance along section according to current proportion along section
		access dend[dendn]
		dist_vec.x[count] = distance(prop)
		access soma

		// Increases weight (uS) incrementally until a somatic spike is identified using APCount
		for (l = 0; l <= 39; l = l+1) {
			
			// Change resolution to larger weight intervals if weight is not small
			if (l < 10) {
				nc.weight = (l)*0.001 // Increase weight by 0.001 uS increments
			}
			if (l > 9 && l<20) {
				nc.weight = (l-9)*0.01 // Increase weight by 0.01 uS increments
			}
			if (l > 19 && l<30) {
				nc.weight = (l-19)*0.1 // Increase weight by 0.1 uS increments
			}
			if (l > 29) {
				nc.weight = (l-29)*1 // Increase weight by 1 uS increments 
			}
			
			// Records voltage vector
			recV = new Vector()
			recV.record(&dend[dendn].v(prop))
				
			run() // Run simulation
			
			if (AP_N.n > 0) {
				weight_vec.x[count] = nc.weight // Threshold weight (uS)
					
				// Save voltage vector
				sprint(filename10,"modelV_%g_Distance_%g_ThresholdWeight_%g_DendriteNumber.dat",dist_vec.x[count],nc.weight,dendn) // Changes filename on each iteration
				frecV = new File(filename10)
				frecV.wopen(filename10)
				recV.printf(frecV) // Use printf instead of vwrite if you want a text file instead of a binary file
				frecV.close()
				count = count + 1
				break
			}
			if (l > 38) {
				weight_vec.x[count] = (l-29)*1 // If weight = 1, then threshold was not attained
					
				// Save voltage vector
				sprint(filename10,"modelV_%g_Distance_%g_ThresholdWeight_%g_DendriteNumber.dat",dist_vec.x[count],nc.weight,dendn) // Changes filename on each iteration
				frecV = new File(filename10)
				frecV.wopen(filename10)
				recV.printf(frecV) // Use printf instead of vwrite if you want a text file instead of a binary file
				frecV.close()
				count = count + 1
				break
			}
		}
	}

	// Store corresponding weight & distance vectors in files
	sprint(filename, "model_%g_dend_weightvec.dat",dendn)
	fok = new File(filename)
	fok.wopen(filename)
	weight_vec.printf(fok) // Use printf instead of vwrite if you want a text file instead of a binary file
	fok.close()
	
	sprint(filename2, "model_%g_dend_distvec.dat",dendn)
	fdist = new File(filename2)
	fdist.wopen(filename2)
	dist_vec.printf(fdist)
	fdist.close()
	count = 0 // Reset count for new vectors
}




